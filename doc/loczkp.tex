\documentclass[a4paper,12pt]{article}
\usepackage{amsmath,amssymb,url}
\usepackage[unicode]{hyperref}


\author{Vadym Fedyukovych\\
  \small{
       \url{https://platin.io/}
%       vadym at platin.io
  }
}
\title{Private location verification with incentivization\\
  \small{in-progress}
}


\begin{document}
\maketitle
\abstract{
  We design an interactive proof system
  for ``location is close enough'' statement,
  in the form of specification for further implementation.
}

\section{Definitions}
Node proves the statement "distance is within a threshold" (less or equal)
for node coordinates $(x_n, y_n, z_n)$,
given location $(x_l, y_l, z_l)$,
and some threshold $d$ (all integers):
\begin{gather}
\label{eq-distn}
  d^2 - ((x_n - x_l)^2 + (y_n - y_l)^2 + (z_n - z_l)^2) = a_1^2 + a_2^2 + a_3^2 + a_4^2
\end{gather}
We rely on 4-squares Lagrange theorem to prove equality statement (Lipmaa).
Proofs for integer relations are possible in hidden group order setup (Camenisch-Stadler).

\section{Proof setup}

Let $g$ be a generator of a proper group of a hidden order,
and $h$ be a group element (Pedersen commitment scheme).
We use multiplicative group of invertible residue classes modulo a composite $n$ such that
$n=pq$, $p=2p'+1$, $q=2q'+1$ and $p, q, p', q'$ primes (Idemix).

\section{Signals harvesting}
Node picks random $(r_x, r_y, r_z)$, creates commitment $(s_x, s_y, s_z)$ to it's coordinates
\begin{gather}
  s_x = g^{x_n} h^{r_x},   \qquad
  s_y = g^{y_n} h^{r_y},   \qquad
  s_z = g^{z_n} h^{r_z}
\end{gather}
and keeps coordinates-randoms pairs
$(x_n, y_n, z_n)$, $(r_x, r_y, r_z)$
private.

\section{Proof}
Sigma-protocol with 3 messages.
Public information is node location commitment, given location, threshold, proof parameters.
Private information is node location and randomness to commitment.

\begin{enumerate}
\item
  Prover (node) picks random $\alpha_j, \beta_x, \beta_y, \beta_z, \rho_0, \rho_1, \eta_x, \eta_y, \eta_z$
  and computes initial commitments $b_0, b_1, t_x, t_y, t_z$ \\
  ($f_0$ and $f_1$ explained at Background section)
\begin{gather}
  b_0 = g^{f_0} h^{\rho_0},   \qquad
  b_1 = g^{f_1} h^{\rho_1}    \\
  t_x = g^{\beta_x} h^{\eta_x},   \qquad
  t_y = g^{\beta_y} h^{\eta_y},   \qquad
  t_z = g^{\beta_z} h^{\eta_z}
\end{gather}

\item
  Challenge $c$
\item
  Prover computes responses
\begin{gather}
%  d^2 - ((x_n - x_l)^2 + (y_n - y_l)^2 + (z_n - z_l)^2) =
  X_n = c x_n + \beta_x,  \quad
  Y_n = c y_n + \beta_y,  \quad
  Z_n = c z_n + \beta_z   \\
  R_x = c r_x + \eta_x,   \quad
  R_y = c r_y + \eta_y,   \quad
  R_z = c r_z + \eta_z    \\
  A_j = c a_j + \alpha_j, \; j=1..4  \\
  R_a = c \rho_1 + \rho_0
\end{gather}

\item
  Proof verification
\begin{gather}
\label{verf-distn}
  g^{c^2d - ((X_n - c x_l)^2 + (Y_n - c y_l)^2 + (Z_n - c z_l)^2 ) - (A_1^2 + A_2^2 + A_3^2 + A_4^2)} h^{R_a} = b_1^{c} b_0 \\
%  g^{c^2d - ((X_n - c x_l)^2 + (Y_n - c y_l)^2 + (Z_n - c z_l)^2 ) - (A_1^2 + A_2^2 + A_3^2 + A_4^2)} h^{R_a} = b_1^{-c} b_0^{-1} \\
  g^{X_n} h^{R_x} s_x^{-c} = t_x,  \quad
  g^{Y_n} h^{R_y} s_y^{-c} = t_y,  \quad
  g^{Z_n} h^{R_z} s_z^{-c} = t_z
%  d^2 - ((x_n - x_l)^2 + (y_n - y_l)^2 + (z_n - z_l)^2) = a_1^2 + a_2^2 + a_3^2 + a_4^2
\end{gather}
  
\end{enumerate}

\section{Background}

Consider quadratic (degree 2 in $v$) polynomial
\begin{multline}
  f_V(v) = f_2 v^2 + f_1 v + f_0 = \\
  v^2 d - (((v x_n + \beta_x) - v x_l)^2 +
           ((v y_n + \beta_y) - v y_l)^2 +
           ((v z_n + \beta_z) - v z_l)^2)  \\
        - ((v a_1 + \alpha_1)^2 +
           (v a_2 + \alpha_2)^2 +
           (v a_3 + \alpha_3)^2 +
           (v a_4 + \alpha_4)^2)
\end{multline}
This polynomial is actually linear ($f_2 = 0$, degree-one in $v$)
if, and only if
statement about distance~\eqref{eq-distn} holds for node coordinates that are hidden from verifier.
We evaluate this polynomial at a random point chosen as the challenge of verifier.
It follows, distance verification equation~\eqref{verf-distn}
only needs constant $b_0$ and degree-one $b_1^c$ components.
\begin{gather}
  f_0 = -\beta_x^2 - \beta_y^2 - \beta_z^2 - \alpha_1^2 - \alpha_2^2 - \alpha_3^2 - \alpha_4^2
\end{gather}
\begin{multline}
  f_1 = -2 (x_n - x_l) \beta_x  -2 (y_n - y_l) \beta_y  -2 (z_n - z_l) \beta_z \\
        -2 a_1 \alpha_1 -2 a_2 \alpha_2 -2 a_3 \alpha_3 -2 a_4 \alpha_4
\end{multline}
Prover calculates $b_0, b_1$ from $f_0, f_1$.

\section{Private incentivization}

To engage users, verifier (map service) is giving tokens in exchange for verifying location proofs.
To keep privacy of users, proof verification and token issuance are separated with intermediate tokens.
Intermediate tokens should unlink locations that users were confirming.

Intermediate token is a Schnorr proof instance, non-interactive variant (Fiat-Shamir),
in another group of a known prime order $q$ generated by $g_i$.
Issuing (private) key $x_i$ and public key $X_i$ of map service.

A new blinded intermediate token is sent to user on each successful location verification.
Users unblind their intermediate tokens and periodically exchange them for Platin tokens.

\begin{enumerate}
\item
  Issuer (map service) chooses random $\gamma$
  and sends $\bar w$ to Recipient
\begin{gather}
  \bar w = g_i^{\gamma}
\end{gather}
  
\item
  Recipient (node) chooses random blinding $(\delta, \mu)$,
  produces blinded challenge~$\bar c_i$ and sends it to Issuer
\begin{gather}
  w = \bar w g_i^{-\delta} X_i^{\mu} \\
  \bar c_i = H(w) + \mu  \pmod{q}
\end{gather}
\item
  Issuer produces blinded response $\bar r_i$ and sends it to Recipient
\begin{gather}
  \bar r_i = \bar c_i x_i + \gamma  \pmod{q}
\end{gather}
\item
  Recipient unblinds challenge and response
\begin{gather}
  c_i = \bar c_i - \mu  \pmod{q} \\
  r_i = \bar r_i - \delta  \pmod{q}
\end{gather}
  Intermediate token is $(c_i, r_i)$.
  
\item
  Intermediate token verification (while exchange for Platin tokens)
\begin{gather}
  c_i = H(g_i^{r_i} X_i^{-c_i})
%  w = g_i^{(\bar c_i x + \gamma) - \delta} X_i^{- \bar c_i + \mu} = \bar w g_i^{-\delta} X_i^{\mu}
\end{gather}
\end{enumerate}

%\section{Intermediate token properties}

%Both components of intermediate token
%are statistically (unconditionally) independent from blinded intermediate token.


\section{Todo}

%Add awarding (payment) part to the proof system.\\
Specify ranges for random numbers.\\
Introduce accumulator for a set of time-locations. \\
Design enforcement for ``just one single location at a time''. \\
Add references (bibliography).

\end{document}

